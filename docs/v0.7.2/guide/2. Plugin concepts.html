<html>
    <head>
        <meta http-equiv="Content-type" content="text/html; charset=utf-8"/>
        <title>2. Plugin concepts</title>
        <link rel="stylesheet" href="../css/main.css" type="text/css" media="screen" title="Ref" charset="utf-8"/>
    </head>
    <body class="body">
    <h1><a name="2. Plugin concepts">2. Plugin concepts</a></h1>Central concepts. <h2><a name="2.1. Tenant class">2.1. Tenant class</a></h2>Most applications will have a domain class where you store tenant data. This will probably be named something like <code>User</code>, <code>Customer</code> or <code>Tenant</code>.
By implementing the interface <code>grails.plugin.multitenant.core.Tenant</code> and overriding the <code>Integer tenantId()</code> method, 
the plugin will give you some benefits out of the box.<p class="paragraph"/>The examples below assumes that you have a tenant class similar to this.<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">import</span> grails.plugin.multitenant.core.Tenant<p class="paragraph"/>class Customer <span class="java&#45;keyword">implements</span> Tenant &#123;<p class="paragraph"/>    <span class="java&#45;object">String</span> name<p class="paragraph"/>    <span class="java&#45;object">Integer</span> tenantId() &#123;
        <span class="java&#45;keyword">return</span> <span class="java&#45;keyword">this</span>.id
    &#125;<p class="paragraph"/>&#125;</pre></div><p class="paragraph"/><h3>Automatic tenant events</h3><p class="paragraph"/>The plugin will trigger a few custom events when changes are made to your tenant domain class. 
This can be very useful for things like maintaining a cache for fast lookups.<p class="paragraph"/>The following events are published when a tenant has been added, updated or deleted: <code>tenant.created</code>, <code>tenant.updated</code> and <code>tenant.deleted</code>.<p class="paragraph"/><div class="code"><pre>class MyTenantService <span class="java&#45;keyword">implements</span> InitializingBean &#123;<p class="paragraph"/>    def eventBroker<p class="paragraph"/>    void afterPropertiesSet() &#123;
        eventBroker.subscribe(<span class="java&#45;quote">"tenant.createed"</span>) &#123; evt &#45;&#62;
            println <span class="java&#45;quote">"New tenant created: "</span> + evt.payload
        &#125;    
    &#125;<p class="paragraph"/>&#125;</pre></div><p class="paragraph"/>Have a look at the <a href="http://multi-tenant.github.com/grails-hawk-eventing/" target="blank">documentation for Hawk Eventing</a> for information on how to subscribe to these events.<p class="paragraph"/><h4>Dynamic methods</h4><p class="paragraph"/>The plugin adds a few methods to your <code>Tenant</code> class.<p class="paragraph"/><h5>withThisTenant</h5><p class="paragraph"/>Normally you want as much as possible of the multi-tenant stuff to happen transparently behind the scenes, but there are cases where it's useful to be able to run operations on a specific tenant. This is often useful during testing and bootstrapping of the application during development.<p class="paragraph"/><div class="code"><pre>def customerX = <span class="java&#45;keyword">new</span> Customer(name: <span class="java&#45;quote">"Customer X"</span>)
customerX.save()<p class="paragraph"/>customerX.withThisTenant &#123;
    // All Hibernate related operations executed here
    // will happen with 'Customer X' as current tenant. 
&#125;</pre></div><p class="paragraph"/><h5>withTenantId</h5><p class="paragraph"/>This is method is similar to <code>withThisTenant</code>, but is added to the static meta class. 
It's useful when you don't have the tenant instance available, but you know the tenant-id.<p class="paragraph"/><div class="code"><pre>Customer.withTenantId(123) &#123;
    // All Hibernate related operations executed here
    // will be executed with tenant id 123. 
&#125;</pre></div><p class="paragraph"/>This method is added to the Tenant interface either, so, whatever you Tenant class is named (<code>Customer</code>, <code>User</code>, etc), you can always use:<p class="paragraph"/><div class="code"><pre>Tenant.withTenantId(123) &#123;
    // All Hibernate related operations executed here
    // will be executed with tenant id 123. 
&#125;</pre></div><p class="paragraph"/><h5>withoutTenantRestriction</h5><p class="paragraph"/>This method does the opposite of others. The plugin executes the closure passed as parameter without any tenant restrictions.
For example, if you're running on tenant 1, and run the following code:<p class="paragraph"/><div class="code"><pre>def messages = &#91;&#93;<p class="paragraph"/>Customer.withoutTenantRestriction &#123;
    // All Hibernate related operations executed here
    // will be executed without any tenant restriction.
    messages = Message.list()
&#125;</pre></div><p class="paragraph"/>It will return all messages in the database, even <code>Message</code> being a <code>&#64;MultiTenant</code> annotated class.<p class="paragraph"/>This method, as <code>withTenantId</code>, is added to the Tenant interface, so, whatever you can use:<p class="paragraph"/><div class="code"><pre>Customer.withoutTenantRestriction &#123;
    // All Hibernate related operations executed here
    // will be executed without any tenant restriction.
&#125;</pre></div><h2><a name="2.2. Multi tenant domain classes">2.2. Multi tenant domain classes</a></h2><h3>The &#64;MultiTenant annotation</h3><p class="paragraph"/>The <code>&#64;MultiTenant</code> annotation is a central part of this plugin. This annotation causes two things to happen.<p class="paragraph"/>The annotation is part of a AST transformation hooking into the compilation process adding a <code>Integer tenantId</code> field to all annotated domain classes.
The transformation also adds the <code>MultiTenantDomainClass</code> interface if the domain class isn't already implementing it.<p class="paragraph"/>The application will look for Hibernate domain classes annotated with &#64;MultiTenant during application startup. 
Hibernate operations against these domain classes will be filtered to only affect data belonging to the current tenant.<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">import</span> grails.plugin.multitenant.core.annotation.MultiTenant<p class="paragraph"/>@MultiTenant
class Animal &#123;<p class="paragraph"/>    <span class="java&#45;object">String</span> name<p class="paragraph"/>&#125;</pre></div><p class="paragraph"/><h3>The unique constraint</h3><p class="paragraph"/>You must take some extra care with the unique constraint as all tenants will share the same database. 
In the future we might add this automatically during application startup.<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">import</span> grails.plugin.multitenant.core.annotation.MultiTenant<p class="paragraph"/>@MultiTenant
class Animal &#123;<p class="paragraph"/>    <span class="java&#45;object">String</span> name<p class="paragraph"/>    <span class="java&#45;keyword">static</span> constraints = &#123;
        name unique: 'tenantId'
    &#125;<p class="paragraph"/>&#125;</pre></div><h2><a name="2.3. Tenant resolver">2.3. Tenant resolver</a></h2>The <strong class="bold">tenant resolver</strong> is point on your application that will detect witch tenant will deal the current request that is made on your application.
Most multi-tenant applications would define tenant based on the URL used to reach your application, but you can check for some user's session attribute, 
or any other thing that you want.<p class="paragraph"/>When implementing your own tenant resolver, you'll have to implement the <code>grails.plugin.multitenant.core.resolve.TenantResolver</code> 
interface and override the <code>public Integer resolve(HttpServletRequest request)</code> method.<p class="paragraph"/>For example, imagine you have the '*.greatapp.com' hosting your application.
<ul class="star">
<li>Requests coming from 'john.greatapp.com' would resolve the tenant for user john, so tenant 1</li>
<li>Requests coming from 'mary.greatapp.com' would resolve the tenant for user mary, so tenant 2</li>
<li>Requests coming from 'paul.greatapp.com' would resolve the tenant for user paul, so tenant 3</li>
</ul><p class="paragraph"/>The code below shows how a simple Tenant Resolver implementation should be.<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">import</span> grails.plugin.multitenant.core.resolve.TenantResolver<p class="paragraph"/>class TenantDomainResolver <span class="java&#45;keyword">implements</span> TenantResolver &#123;<p class="paragraph"/>    @Override
    <span class="java&#45;keyword">public</span> <span class="java&#45;object">Integer</span> resolve(HttpServletRequest request) &#123;<p class="paragraph"/>        <span class="java&#45;object">String</span> host = request.getServerName()
        <span class="java&#45;keyword">switch</span> (host) &#123;
            <span class="java&#45;keyword">case</span> <span class="java&#45;quote">"john.greatapp.com"</span>:
                <span class="java&#45;keyword">return</span> 1<p class="paragraph"/>            <span class="java&#45;keyword">case</span> <span class="java&#45;quote">"mary.greatapp.com"</span>:
                <span class="java&#45;keyword">return</span> 2<p class="paragraph"/>            <span class="java&#45;keyword">case</span> <span class="java&#45;quote">"paul.greatapp.com"</span>:
                <span class="java&#45;keyword">return</span> 3<p class="paragraph"/>            <span class="java&#45;keyword">default</span>:
                <span class="java&#45;keyword">return</span> <span class="java&#45;keyword">null</span>
        &#125;
    &#125;<p class="paragraph"/>&#125;</pre></div><p class="paragraph"/>Of course, your application will probably look this information up from a database.
Host names rarely change so if you resolve tenants based on the host http header you might want
to implement a host =&#62; tenant-id cache here.<p class="paragraph"/><blockquote class="warning">
In the example above, if the tenant has not been found, it would return null. <strong class="bold">Be careful with this approach</strong>, 
returning null, query restrictions will not be applied, so, data of all tenants will be returned when queried.
</blockquote><h2><a name="2.4. Tenant repository">2.4. Tenant repository</a></h2>The <code>tenantRepository</code> bean's responsibility is to look up Tenant instances based on the numeric tenant id 
(provided by the <code>tenantResolver</code> bean stored in <code>currentTenant</code>). Running the <code>mt-quickstart</code> script will generate a basic implementation for you.  <h2><a name="2.5. Tenant scoped beans">2.5. Tenant scoped beans</a></h2>The plugin ships with  <em class="italic">experimental</em>  support for per-tenant beans. 
It's implemented using a custom tenant scope in combination with a scoped proxy.<p class="paragraph"/><h3>Configured in config.groovy:</h3><p class="paragraph"/>This feature can be configured through config.groovy. See example below:<p class="paragraph"/><div class="code"><pre>multiTenant &#123;
    perTenantBeans = &#91; <span class="java&#45;quote">"someSpringBean"</span> &#93;
&#125;</pre></div><p class="paragraph"/><h3>The static scope property in Grails services</h3><p class="paragraph"/>This will only work for Grails service artifacts.<p class="paragraph"/><div class="code"><pre>class MyService &#123;<p class="paragraph"/>    <span class="java&#45;keyword">static</span> scope = <span class="java&#45;quote">"tenant"</span><p class="paragraph"/>&#125;</pre></div><p class="paragraph"/><h3>Spring's &#64;Scope annotation</h3><p class="paragraph"/>Spring 2.5 introduced a <code>&#64;Scope</code> annotation, but this seems to be tied to component scanning 
and will not work out of the box with the custom tenant scope introduced by this plugin.
    </body>
</html>
