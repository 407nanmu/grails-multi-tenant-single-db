<html>
    <head>
        <meta http-equiv="Content-type" content="text/html; charset=utf-8"/>
        <title>2.1. Tenant class</title>
        <link rel="stylesheet" href="../css/main.css" type="text/css" media="screen" title="Ref" charset="utf-8"/>
    </head>
    <body class="body">
    Most applications will have a domain class where you store tenant data. This will probably be named something like <code>User</code>, <code>Customer</code> or <code>Tenant</code>.
By implementing the interface <code>grails.plugin.multitenant.core.Tenant</code> and overriding the <code>Integer tenantId()</code> method, 
the plugin will give you some benefits out of the box.<p class="paragraph"/>The examples below assumes that you have a tenant class similar to this.<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">import</span> grails.plugin.multitenant.core.Tenant<p class="paragraph"/>class Customer <span class="java&#45;keyword">implements</span> Tenant &#123;<p class="paragraph"/>    <span class="java&#45;object">String</span> name<p class="paragraph"/>    <span class="java&#45;object">Integer</span> tenantId() &#123;
        <span class="java&#45;keyword">return</span> <span class="java&#45;keyword">this</span>.id
    &#125;<p class="paragraph"/>&#125;</pre></div><p class="paragraph"/><h3>Automatic tenant events</h3><p class="paragraph"/>The plugin will trigger a few custom events when changes are made to your tenant domain class. 
This can be very useful for things like maintaining a cache for fast lookups.<p class="paragraph"/>The following events are published when a tenant has been added, updated or deleted: <code>tenant.created</code>, <code>tenant.updated</code> and <code>tenant.deleted</code>.<p class="paragraph"/><div class="code"><pre>class MyTenantService <span class="java&#45;keyword">implements</span> InitializingBean &#123;<p class="paragraph"/>    def eventBroker<p class="paragraph"/>    void afterPropertiesSet() &#123;
        eventBroker.subscribe(<span class="java&#45;quote">"tenant.createed"</span>) &#123; evt &#45;&#62;
            println <span class="java&#45;quote">"New tenant created: "</span> + evt.payload
        &#125;    
    &#125;<p class="paragraph"/>&#125;</pre></div><p class="paragraph"/>Have a look at the <a href="http://multi-tenant.github.com/grails-hawk-eventing/" target="blank">documentation for Hawk Eventing</a> for information on how to subscribe to these events.<p class="paragraph"/><h4>Dynamic methods</h4><p class="paragraph"/>The plugin adds a few methods to your <code>Tenant</code> class.<p class="paragraph"/><h5>withThisTenant</h5><p class="paragraph"/>Normally you want as much as possible of the multi-tenant stuff to happen transparently behind the scenes, but there are cases where it's useful to be able to run operations on a specific tenant. This is often useful during testing and bootstrapping of the application during development.<p class="paragraph"/><div class="code"><pre>def customerX = <span class="java&#45;keyword">new</span> Customer(name: <span class="java&#45;quote">"Customer X"</span>)
customerX.save()<p class="paragraph"/>customerX.withThisTenant &#123;
    // All Hibernate related operations executed here
    // will happen with 'Customer X' as current tenant. 
&#125;</pre></div><p class="paragraph"/><h5>withTenantId</h5><p class="paragraph"/>This is method is similar to <code>withThisTenant</code>, but is added to the static meta class. 
It's useful when you don't have the tenant instance available, but you know the tenant-id.<p class="paragraph"/><div class="code"><pre>Customer.withTenantId(123) &#123;
    // All Hibernate related operations executed here
    // will be executed with tenant id 123. 
&#125;</pre></div><p class="paragraph"/>This method is added to the Tenant interface either, so, whatever you Tenant class is named (<code>Customer</code>, <code>User</code>, etc), you can always use:<p class="paragraph"/><div class="code"><pre>Tenant.withTenantId(123) &#123;
    // All Hibernate related operations executed here
    // will be executed with tenant id 123. 
&#125;</pre></div><p class="paragraph"/><h5>withoutTenantRestriction</h5><p class="paragraph"/>This method does the opposite of others. The plugin executes the closure passed as parameter without any tenant restrictions.
For example, if you're running on tenant 1, and run the following code:<p class="paragraph"/><div class="code"><pre>def messages = &#91;&#93;<p class="paragraph"/>Customer.withoutTenantRestriction &#123;
    // All Hibernate related operations executed here
    // will be executed without any tenant restriction.
    messages = Message.list()
&#125;</pre></div><p class="paragraph"/>It will return all messages in the database, even <code>Message</code> being a <code>&#64;MultiTenant</code> annotated class.<p class="paragraph"/>This method, as <code>withTenantId</code>, is added to the Tenant interface, so, whatever you can use:<p class="paragraph"/><div class="code"><pre>Customer.withoutTenantRestriction &#123;
    // All Hibernate related operations executed here
    // will be executed without any tenant restriction.
&#125;</pre></div>
    </body>
</html>
