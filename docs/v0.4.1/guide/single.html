<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>multi-tenant-single-db 0.4.1 - Reference Documentation</title>
        <link rel="stylesheet" href="../css/main.css" type="text/css" media="screen" title="Style" charset="utf-8"/>
        <link rel="stylesheet" href="../css/pdf.css" type="text/css" media="print" title="PDF" charset="utf-8" />
    </head>
    <body class="body">
        <div id="header">
            <div class="images"><br/><br/>
                <a href="http://grails.org" target="_blank"><img alt="The Grails Framework" src="../img/grails.png" border="0"/></a>
                <span style="right:30px; top:20px; position:absolute;">
                    <a href="../index.html" target="_top">Frames</a> | <a href="index.html" target="_top">No Frames</a><br/><br/>
                    <a href="http://springsource.com" target="_blank"><img alt="SpringSource - A Division of VMware" src="../img/springsource-logo.png" border="0"/></a>
                </span>
            </div>
            <div class="message">multi-tenant-single-db</div>
            <h1>multi-tenant-single-db - Reference Documentation</h1>
            <p><strong>Authors:</strong> Kim A. Betti</p>
            <p><strong>Version:</strong> 0.4.1</p>
            <em></em>
        </div>

        <div id="toc">
            <h2>Table of Contents</h2>
            <div class="tocItem" style="margin-left:0px"><a href="#1. Introduction">1. Introduction</a></div><div class="tocItem" style="margin-left:10px"><a href="#1.1 This plugin vs. multi-tenant-core">1.1 This plugin vs. multi-tenant-core</a></div><div class="tocItem" style="margin-left:10px"><a href="#1.2 Design goals">1.2 Design goals</a></div><div class="tocItem" style="margin-left:10px"><a href="#1.3 Single database mode">1.3 Single database mode</a></div><div class="tocItem" style="margin-left:0px"><a href="#2. Tenant resolver">2. Tenant resolver</a></div><div class="tocItem" style="margin-left:0px"><a href="#3. Domain classes">3. Domain classes</a></div><div class="tocItem" style="margin-left:10px"><a href="#3.1 Annotation">3.1 Annotation</a></div><div class="tocItem" style="margin-left:10px"><a href="#3.2 Unique constraint">3.2 Unique constraint</a></div><div class="tocItem" style="margin-left:0px"><a href="#4. Tenant domain class">4. Tenant domain class</a></div><div class="tocItem" style="margin-left:10px"><a href="#4.1 Automatic tenant events">4.1 Automatic tenant events</a></div><div class="tocItem" style="margin-left:10px"><a href="#4.2 Dynnamic methods">4.2 Dynnamic methods</a></div><div class="tocItem" style="margin-left:0px"><a href="#5. Per tenant beans">5. Per tenant beans</a></div><div class="tocItem" style="margin-left:0px"><a href="#6. Testing">6. Testing</a></div>
        </div>
        <div id="content">
            <h1><a name="1. Introduction">1. Introduction</a></h1>The Multi Tenant plugin aims to make it easy to set up and develop a multi-tenant application based on Hibernate. 
A multi tenant application will let you run multiple users or customers in the same application instance without them 
being able to see or modify each others data.<p class="paragraph"/>So far this plugin works in "single database" mode. This means that all your tenants will share the same database and tables. 
Hibernate will re-write queries before they hit the database so only data belonging to the  <em class="italic">current</em>  tenant will be fetched. <h2><a name="1.1 This plugin vs. multi-tenant-core">1.1 This plugin vs. multi-tenant-core</a></h2>The original plan was to merge at least some of the solutions in this plugin back into <a href="http://github.com/multi-tenant/grails-multi-tenant-core" target="blank">multi-tenant-core</a>, but.. 
<ol>
<li>That would introduce two unnecessary dependencies (Hawk Eventing and Hibernate Hijacker) for those using the multi-database mode.</li>
<li>Some of the changes in this plugin would break existing applications.</li>
</ol><p class="paragraph"/><h2><a name="1.2 Design goals">1.2 Design goals</a></h2><h3>Main focus</h3>
<ol>
<li>Focus on single-database mode, while trying to keep the door open for later support for database per tenant as long as it doesn't add too much complexity.</li>
<li>Make sure that the webflow plugin is supported. Without forcing anyone to install it into their projects.</li>
<li>Re-think some design decisions and add more support for the most common use cases.</li>
</ol><p class="paragraph"/><h3>Very long term, possibly never (depending on interest and patches)</h3>
<ol>
<li>Create a separate core plugin independent of Hibernate.</li>
<li>Support multiple-database mode? Hibernate Shards?</li>
<li>Implement support forÂ name-of-latest-and-greatest-nosql-hype-here</li>
</ol><p class="paragraph"/><h2><a name="1.3 Single database mode">1.3 Single database mode</a></h2>This plugin is (at least for the time being) focusing solely on single database mode. 
What this means is that every tenant (user, customer..) shares that same database. 
Hibernate will filter all queries targeting multi-tenant domain classes before they hit the database.<p class="paragraph"/>With a multi database approach tenant data will be stored in separate databases. 
This is often a requirement from 'enterprise' customers like banks, governments 
and companies with more lawyers than developers.<p class="paragraph"/><h4>Pros</h4>
<ul class="star">
<li>Tenants can be created and deleted without any maintenance overhead.</li>
<li>You can backup and restore everything in one operation.</li>
</ul><p class="paragraph"/><h4>Cons</h4>
<ul class="star">
<li>Backup can be more difficult. In a multi database environment you can backup and restore individual tenants. This is obviously a lot more tricky if all tenants share one database.</li>
<li>You might run into database scaling challenges if your tenants produce a lot of data. You might look into key based partitioning.</li>
</ul><p class="paragraph"/>This is by no means a complete list, it's just a couple of points from the top
of my head to give you an idea of what you're buying into, feel free to suggest more pros'n'cons.  <h1><a name="2. Tenant resolver">2. Tenant resolver</a></h1>You can see a naive implementation of this interface below. 
Your application will probably look this information up from a database.<p class="paragraph"/><div class="code"><pre>class CachingTenantDomainResolver <span class="java&#45;keyword">implements</span> TenantResolver &#123;<p class="paragraph"/>    @Override
    <span class="java&#45;keyword">public</span> <span class="java&#45;object">int</span> resolve(HttpServletRequest request) &#123;
        <span class="java&#45;object">String</span> host = request.getServerName();
        <span class="java&#45;keyword">switch</span> (host) &#123;
            <span class="java&#45;keyword">case</span> <span class="java&#45;quote">"customer&#45;a.com"</span>:
                <span class="java&#45;keyword">return</span> 1<p class="paragraph"/>            <span class="java&#45;keyword">case</span> <span class="java&#45;quote">"customer&#45;b.com"</span>:
                <span class="java&#45;keyword">return</span> 2<p class="paragraph"/>            <span class="java&#45;keyword">default</span>:
                <span class="java&#45;keyword">return</span> <span class="java&#45;keyword">null</span>
        &#125;
    &#125;<p class="paragraph"/>&#125;</pre></div><p class="paragraph"/><blockquote class="note">
Error handling is subject to change. We're still looking for a "best practice". 
</blockquote><h1><a name="3. Domain classes">3. Domain classes</a></h1><h2><a name="3.1 Annotation">3.1 Annotation</a></h2>The &#64;MultiTenant annotation is a central part of this plugin. This annotation causes two things to happen.<p class="paragraph"/><h3>During compilation</h3><p class="paragraph"/>The annotation hooks into the compilation process and adds a <code>Integer tenantId</code> field to all annotated domain classes.<p class="paragraph"/><h3>During application startup</h3><p class="paragraph"/>The application will look for Hibernate domain classes annotated with &#64;MultiTenant during application startup. 
Hibernate operations against these domain classes will be filtered to only affect data belonging to the current tenant.<p class="paragraph"/><div class="code"><pre>@MultiTenant
class Animal &#123;<p class="paragraph"/>    <span class="java&#45;object">String</span> name<p class="paragraph"/>&#125;</pre></div><h2><a name="3.2 Unique constraint">3.2 Unique constraint</a></h2>You must take some extra care with the unique constraint as all tenants will share the same database. 
In the future we might add this automatically during application startup.<p class="paragraph"/><div class="code"><pre>@MultiTenant
class Animal &#123;<p class="paragraph"/>    <span class="java&#45;object">String</span> name<p class="paragraph"/>    <span class="java&#45;keyword">static</span> constraints = &#123;
        name unique: 'tenantId'
    &#125;<p class="paragraph"/>&#125;</pre></div><h1><a name="4. Tenant domain class">4. Tenant domain class</a></h1>Most applications will have a domain class where you store tenant data. This will probably be named something like <code>User</code>, <code>Customer</code> or <code>Tenant</code>.
By implementing the interface <code>grails.plugin.multitenant.core.Tenant</code> the plugin will give you some benefits out of the box.  <h2><a name="4.1 Automatic tenant events">4.1 Automatic tenant events</a></h2>The plugin will trigger a few custom events when changes are made to your tenant domain class. 
This can be very useful for things like maintaining a cache for fast lookups.<p class="paragraph"/>The following events are published when a tenant has been added, updated or deleted: <code>tenant.created</code>, <code>tenant.updated</code> and <code>tenant.deleted</code>.
Have a look at the <a href="http://multi-tenant.github.com/grails-hawk-eventing/" target="blank">documentation for Hawk Eventing</a> for information on how to subscribe to these events.<p class="paragraph"/><div class="code"><pre>class MyTenantService <span class="java&#45;keyword">implements</span> InitializingBean &#123;<p class="paragraph"/>    def eventBroker<p class="paragraph"/>    void afterPropertiesSet() &#123;
        eventBroker.subscribe(<span class="java&#45;quote">"tenant.createed"</span>) &#123; evt &#45;&#62;
            println <span class="java&#45;quote">"New tenant created: "</span> + evt.payload
        &#125;    
    &#125;<p class="paragraph"/>&#125;</pre></div><h2><a name="4.2 Dynnamic methods">4.2 Dynnamic methods</a></h2>The plugin adds a few methods to your <code>Tenant</code> class.<p class="paragraph"/>The examples below assumes that you have a tenant class similar to this.<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">import</span> grails.plugin.multitenant.core.Tenant<p class="paragraph"/>class Customer <span class="java&#45;keyword">implements</span> Tenant &#123;<p class="paragraph"/>    <span class="java&#45;object">String</span> name<p class="paragraph"/>    <span class="java&#45;object">Integer</span> getTenantId() &#123;
        <span class="java&#45;keyword">return</span> <span class="java&#45;keyword">this</span>.id
    &#125;<p class="paragraph"/>&#125;</pre></div><p class="paragraph"/>
<h3>withThisTenant</h3><p class="paragraph"/>Normally you want as much as possible of the multi-tenant stuff to happen transparently behind the scenes, but there are cases where it's useful to be able to 
run operations on a specific tenant. This is often useful during testing and bootstrapping of the application during development.<p class="paragraph"/><div class="code"><pre>def customerX = <span class="java&#45;keyword">new</span> Customer(name: <span class="java&#45;quote">"Customer X"</span>)<p class="paragraph"/>customerX.withThisTenant &#123;
    // All Hibernate related operations executed here
    // will happen with 'Customer X' as current tenant.<p class="paragraph"/>&#125;</pre></div><p class="paragraph"/><h3>withTenantId</h3><p class="paragraph"/>This is method is similar to <code>withThisTenant</code>, but is added to the static meta class. 
It's useful when you don't have the tenant instance available, but you know the tenant-id.<p class="paragraph"/><div class="code"><pre>Customer.withTenantId(123) &#123;
    // All Hibernate related operations executed here
    // will be executed with tenant id 123. 
&#125;</pre></div><p class="paragraph"/><h1><a name="5. Per tenant beans">5. Per tenant beans</a></h1>I recently added  <em class="italic">experimental</em>  support for per-tenant beans. It's implemented using a custom tenant bean scope in combination with a scoped proxy.<p class="paragraph"/>This feature can be configured through config.groovy. See example below-<p class="paragraph"/><div class="code"><pre>multiTenant &#123;
    perTenantBeans = &#91; <span class="java&#45;quote">"someSpringBean"</span> &#93;
&#125;</pre></div><h1><a name="6. Testing">6. Testing</a></h1><blockquote class="note">
We'd like to add some extra support for multi-tenant testing, but we're not quite there yet. 
</blockquote>
        </div>
        <div id="footer">
             Have a nice day!
        </div>
    </body>
</html>
